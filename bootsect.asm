use16
org 0x7C00

start:
	; Инициализация адресов сегментов. Эти операции требуется не для любого BIOS, но их рекомендуется проводить.
	mov ax, cs ; Сохранение адреса сегмента кода в ax
	mov ds, ax ; Сохранение этого адреса как начало сегмента данных
	mov ss, ax ; И сегмента стека
	mov sp, start ; Сохранение адреса стека как адрес первой инструкции этого кода. Стек будет расти вверх и не перекроет код.
	
;--------------------------------------------------------------------
	; Выводим строку "Press: 1 - green, 2 - blue, 3 - red, 4 - yellow, 5 - gray, 6 - white"
	mov bx, loading_str
    call puts
    mov al, 0ah ;Перевод строки   
    int 10h 
    mov al, 0dh ; Возврат каретки
    int 10h 
    jmp symbol

; Функция вывод строки 
puts:
    mov al, [bx+0]
    test al, al
    jz end_puts
    mov ah, 0x0e
    int 0x10
    add bx, 1
    jmp puts
end_puts:
    ret

    loading_str:
db "Press: 1 - green, 2 - blue, 3 - red, 4 - yellow, 5 - gray, 6 - white", 0

; Считываем символ
symbol:
    mov ah, 0x0
    int 0x16    
    cmp al, 0x31
    je same   
    cmp al, 0x32
    je same   
    cmp al, 0x33
    je same   
    cmp al, 0x34
    je same   
    cmp al, 0x35
    je same   
    cmp al, 0x36
    je same
    jmp wrongSymbol 

wrongSymbol:
    mov bx, loading_str_2
    call puts
    mov al, 0ah   ; перевод строки    
    int 10h 
    mov al, 0dh  
    int 10h 
    jmp symbol

    loading_str_2:
db "Wrong Symbol", 0
	    
same:
; Помещаем считанный символ для передачи в операционную систему
    mov [0x9000], al
;--------------------------------------------------------------------
	mov bx, 0x1000
	mov es, bx 
	mov bx, 0x0000 
	mov ch, 0 ; Номер цилиндра (старшие 2 бита cl/ch)
	mov cl, 1 ;               / сектора
	mov dl, 1 ; Номер диска
	mov dh, 0 ; Номер головки
	mov ah, 0x02 ; Параметр 
	mov al, 0x26  ; Количество секторов
	int 0x13  ; прерывание i/o диска

	; Отключение прерываний
	cli
	; Загрузка размера и адреса таблицы дескрипторов
	lgdt [gdt_info] ; Для GNU assembler должно быть "lgdt gdt_info"
	; Включение адресной линии А20
	in al, 0x92
	or al, 2
	out 0x92, al
	; Установка бита PE регистра CR0 - процессор перейдет в защищенный режим
	mov eax, cr0
	or al, 1
	mov cr0, eax
	jmp 0x8:protected_mode ; "Дальний" переход для загрузки корректной информации в cs (архитектурные особенности не позволяют этого сделать напрямую).

gdt: ;Минимальная таблица дескрипторов должна состоять из трех записей:
	; Нулевой дескриптор
	db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	; Сегмент кода: base=0, size=4Gb, P=1, DPL=0, S=1(user),
	; Type=1(code), Access=00A, G=1, B=32bit
	db 0xff, 0xff, 0x00, 0x00, 0x00, 0x9A, 0xCF, 0x00
	; Сегмент данных: base=0, size=4Gb, P=1, DPL=0, S=1(user),
	; Type=0(data), Access=0W0, G=1, B=32bit
	db 0xff, 0xff, 0x00, 0x00, 0x00, 0x92, 0xCF, 0x00

gdt_info: ; Данные о таблице GDT (размер, положение в памяти)
	dw gdt_info - gdt ; Размер таблицы (2 байта)
	dw gdt, 0 ; 32-битный физический адрес таблицы.

	use32
	; Здесь идут первые инструкции в защищенном режиме
protected_mode:
	; Загрузка селекторов сегментов для стека и данных в регистры
	mov ax, 0x10 ; Используется дескриптор с номером 2 в GDT
	mov es, ax
	mov ds, ax
	mov ss, ax
	; Передача управления загруженному ядру
	call 0x10000 ; Адрес равен адресу загрузки в случае если ядро скомпилировано в "плоский" код

; Внимание! Сектор будет считаться загрузочным, если содержит в конце своих 512 байтов два следующих байта: 0x55 и 0xAA
	times (512 - ($ - start) - 2) db 0 ; Заполнение нулями до границы 512 - 2 текущей точки
	db 0x55, 0xAA ; 2 необходимых байта чтобы сектор считалжся загрузочным
				  ; Носитель является загрузочным, если считанный сектор содержит байты 0xAA и 0x55
